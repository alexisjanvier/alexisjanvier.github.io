<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Es6 on alexisjanvier.net</title>
    <link>http://alexisjanvier.github.io/tags/es6/index.xml</link>
    <description>Recent content in Es6 on alexisjanvier.net</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr-fr</language>
    <copyright>mon copyright</copyright>
    <atom:link href="http://alexisjanvier.github.io/tags/es6/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Bootstraping du projet ES6</title>
      <link>http://alexisjanvier.github.io/blog/bootstrapping_du_projet_en_es6/</link>
      <pubDate>Tue, 09 Feb 2016 11:35:26 +0100</pubDate>
      
      <guid>http://alexisjanvier.github.io/blog/bootstrapping_du_projet_en_es6/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Prérequis&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Le projet va être développé avec :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;node.js&lt;/code&gt; version 5.5.0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm&lt;/code&gt; version 3.3.12&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;J&amp;rsquo;utilise &lt;a href=&#34;https://github.com/creationix/nvm&#34;&gt;nvm&lt;/a&gt; pour gérer différentes versions de &lt;code&gt;node&lt;/code&gt;, avec un peu de configuration de &lt;code&gt;npm&lt;/code&gt; pour accélérer l&amp;rsquo;installation des modules, et fixer leur version :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm config set progress=false
npm config set save-prefix=&#39;~&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;transpilation-avec-babel&#34;&gt;Transpilation avec Babel&lt;/h1&gt;

&lt;p&gt;Je vais utiliser &lt;a href=&#34;https://babeljs.io/&#34;&gt;Babel&lt;/a&gt; pour transpiler le code ES6 en ES5. La version 6 a introduit une nouvelle organisation du projet. Il faut maintenant installer au minimum &lt;strong&gt;babel-core&lt;/strong&gt;, sur lequel vont s&amp;rsquo;appuyer tous les autres modules.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install babel-core –save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ensuite, il faut installer &lt;strong&gt;babel-cli&lt;/strong&gt; permettant entre autres de vérifier l&amp;rsquo;environnement avec &lt;strong&gt;babel-doctor&lt;/strong&gt; ainsi que &lt;strong&gt;babel-node&lt;/strong&gt; qui lui permet de lancer des scripts ES6 avec node avec une transpilation dynamique (on a ainsi un &lt;strong&gt;REPL ES6&lt;/strong&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install babel-cli –save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Enfin, Babel utilise maintenant un système de &lt;strong&gt;presets&lt;/strong&gt; permettant de ne transpiler que ce qui sera nécessaire au code final en fonction de son environnement d&amp;rsquo;exécution, en l&amp;rsquo;occurrence le navigateur.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install babel-preset-es2015
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# package.json

  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;babel-cli&amp;quot;: &amp;quot;~6.5.1&amp;quot;,
    &amp;quot;babel-core&amp;quot;: &amp;quot;~6.5.1&amp;quot;,
    &amp;quot;babel-preset-es2015&amp;quot;: &amp;quot;~6.5.0&amp;quot;
  },
  &amp;quot;babel&amp;quot;: {
    &amp;quot;presets&amp;quot;: [
      &amp;quot;es2015&amp;quot;
    ]
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Remarque :&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;J&amp;rsquo;ai configuré le preset de Babel directement dans le fichier &lt;code&gt;package.json&lt;/code&gt;. Il est également possible de réaliser cette configuration dans un fichier &lt;code&gt;.babelrc&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Je conseille la lecture de l&amp;rsquo;article de &lt;a href=&#34;https://twitter.com/jcse&#34;&gt;Jean-Charles Sisk&lt;/a&gt;, &lt;a href=&#34;https://medium.com/@jcse/clearing-up-the-babel-6-ecosystem-c7678a314bf3#.nfrmt64p8&#34;&gt;« &lt;strong&gt;&lt;em&gt;Clearing up the Babel 6 Ecosystem &lt;/em&gt;&lt;/strong&gt;»&lt;/a&gt; pour avoir plus de détail sur Babel 6.&lt;/p&gt;

&lt;p&gt;Maintenant, il faut choisir si l&amp;rsquo;on veut utiliser Babel :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;dynamiquement&lt;/strong&gt; directement au niveau du navigateur,&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;statiquement&lt;/strong&gt; au niveau du serveur en générant un fichier .js transpilé, fichier qui sera ensuite appelé par le navigateur.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;C&amp;rsquo;est la solution que je vais utiliser (expliquant la déclaration des modules Babel en dépendance de développement, puisque Babel ne sera jamais présent dans le js de production).&lt;br /&gt;
Et pour cela, nous allons devoir passer par un autre outil : &lt;a href=&#34;https://webpack.github.io/&#34;&gt;&lt;strong&gt;Webpack&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;webpack&#34;&gt;Webpack&lt;/h1&gt;

&lt;p&gt;Webpack est un « *module bundler* » permettant de gérer notre code es6 écrit en module et générer un fichier final js utilisable dans le navigateur, en effectuant au passage la transpilation ES6 avec Babel.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;webpack takes modules with dependencies and generates static assets representing those modules.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Webpack fait d&amp;rsquo;ailleurs bien plus que cela comme cela sera vu plus tard. Pour le moment, installons le afin de faire un premier test de transpilage de deux modules ES6.&lt;br /&gt;
Tous les fichiers de cette phase de bootstraping sont créés dans le répertoire &lt;code&gt;/src&lt;/code&gt; et utilisent la syntaxe ES6 pour la gestion des modules.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├── src
│   ├── css
│   │   └── main.css
│   ├── index.html
│   └── js
│       ├── main.js
│       └── paris.js
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- src/index.html --&amp;gt;

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;Road to Caen&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;h1&amp;gt;Road to Caen - version 0.1.0&amp;lt;/h1&amp;gt;

&amp;lt;div id=&amp;quot;start_here&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script src=&amp;quot;js/main.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// src/js/main.js

import city from &#39;./paris&#39;;

document.getElementById(&#39;start_here&#39;).innerHTML = `For the moment, you are in ${city}`;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// src/js/city.js

export default &#39;Paris&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Si l&amp;rsquo;on essaye d&amp;rsquo;ouvrir index.html directement dans le navigateur, on a logiquement une erreur :&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://alexisjanvier.github.io/images/rtc_bootstrap/rtc_bootstrap_es6_in_browser_error.png&#34; alt=&#34;De l&#39;ES6 dans le navigateur&#34; /&gt;&lt;/p&gt;

&lt;p&gt;On va donc configurer webpack pour effectuer un build du fichier &lt;code&gt;main.js&lt;/code&gt; dans le répertoire &lt;code&gt;/build&lt;/code&gt;, obligant au passage à installer deux plugins:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install webpack babel-loader copy-webpack-plugin –save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;babel loader&lt;/strong&gt; est un plugin webpack permettant d&amp;rsquo;utiliser Babel dans Webpack&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;copy-webpack-plugin&lt;/strong&gt; est un plugin webpack permettant de copier un fichier d&amp;rsquo;un répertoire à un autre, éventuellement en le renommant.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Je ne vais pas rentrer dans les détails de webpack (vous pouvez pour cela lire xxx ou xxx), mais le grand principe est :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;de déclarer une ou plusieurs sources d&amp;rsquo;entrée (&lt;code&gt;entry&lt;/code&gt;),&lt;/li&gt;
&lt;li&gt;de déclarer une ou plusieurs sources de sortie (&lt;code&gt;output&lt;/code&gt;) correspondant aux entrées,&lt;/li&gt;
&lt;li&gt;des loaders pour les différents types d&amp;rsquo;assets traités (dans l&amp;rsquo;exemple à suivre, on utilise par exemple le &lt;strong&gt;babel-loader&lt;/strong&gt; pour transpiler les fichiers js traités).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On déclare aussi des plugins pour des cas particuliers, comme le plugin &lt;strong&gt;copy-webpack-plugin&lt;/strong&gt; permettant de copier le fichier &lt;code&gt;/src/index.html&lt;/code&gt; dans le répertoire cible &lt;code&gt;/build/&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Fichier de configuration de webpack webpack.config.js à la racine du projet

const path = require(&#39;path&#39;);
const webpack = require(&#39;webpack&#39;);
const CopyWebpackPlugin = require(&#39;copy-webpack-plugin&#39;);

const dirJs = path.resolve(__dirname, &#39;src/js&#39;);
const dirHtml = path.resolve(__dirname, &#39;src&#39;);
const dirBuild = path.resolve(__dirname, &#39;build&#39;);

module.exports = {
    entry: path.resolve(dirJs, &#39;main.js&#39;),
    output: {
        path: dirBuild,
        filename: &#39;js/main.js&#39;,
    },
    module: {
        loaders: [
            {
                test: /\.js$/,
                loader: &#39;babel-loader&#39;,
                exclude: /node_modules/
            },
        ],
    },
    plugins: [
        new CopyWebpackPlugin([
            {
                from: dirHtml + &#39;/index.html&#39;
            },
        ]),
    ],
    stats: {
        colors: true,
    },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;./node_modules/.bin/webpack
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On retrouve au final un fichier &lt;code&gt;index.html&lt;/code&gt; et &lt;code&gt;main.js&lt;/code&gt; dans le répertoire &lt;code&gt;/build/&lt;/code&gt;, que l&amp;rsquo;on peut charger sans erreur dans un navigateur.&lt;/p&gt;

&lt;h1 id=&#34;un-serveur-de-développement&#34;&gt;Un serveur de développement&lt;/h1&gt;

&lt;p&gt;On arrive donc à transpilet notre ES6 dans un fichier unique fichier js, et c&amp;rsquo;est déjà chouette. Mais on ne va pas lancer un build à chaque modifications du code&amp;hellip;&lt;br /&gt;
Pour éviter cela, on va installer le &lt;strong&gt;webpack-dev-server&lt;/strong&gt;, et en profiter pour faire un makefile afin de faciliter le lancement des commandes (&lt;code&gt;make build&lt;/code&gt; pour lancer un transpilation et &lt;code&gt;make run-dev&lt;/code&gt; pour le lancement du serveur de dev), et permettre à d&amp;rsquo;éventuels autre participants au projet de pouvoir facilement installer tout l&amp;rsquo;environnement de développement (&lt;code&gt;make install&lt;/code&gt;).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install webpack-dev-server –save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# makefile

.PHONY: default install run test build clean-build

default: run-dev

install:
	@npm install

clean-build:
	@rm -rf ./build/*

build: clean-build
	@./node_modules/.bin/webpack

run-dev: clean-build
	@./node_modules/.bin/webpack-dev-server --hot --inline --port=8080
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Remarque&lt;/em&gt;&lt;/strong&gt; : &lt;em&gt;on pourrait aussi utiliser &lt;code&gt;npm&lt;/code&gt; pour lancer ces commandes et éviter le &lt;code&gt;node_modules/.bin&lt;/code&gt; vers les exécutables des outils. Mais par habitude, ce sera make.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Le &lt;strong&gt;webpack-dev-server&lt;/strong&gt; est très rapide (il charge le code en mémoire) et permet de faire du &lt;em&gt;live-reload&lt;/em&gt; (option &lt;code&gt;–hot&lt;/code&gt;). On transpile maintenant bien le code ES6 en js lisible par le navigateur à la volée.&lt;br /&gt;
Mais on ne gère que le js, alors que l&amp;rsquo;on veut aussi avoir du css.&lt;/p&gt;

&lt;h1 id=&#34;webpack-et-le-css&#34;&gt;Webpack et le css&lt;/h1&gt;

&lt;p&gt;Pour gérer le css, on ajoute un nouveau plugin et un nouveau loader (pour du css simple, mais on pourra aussi par la suite &amp;ldquo;&lt;em&gt;pre-processer&lt;/em&gt;&amp;rdquo; du &lt;strong&gt;sass&lt;/strong&gt; par exemple, grace à d&amp;rsquo;autres loaders).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install style-loader --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# webpack.config.js

...
module: {
    loaders: [
    {  
        test: /\.css$/,
        loader: &amp;quot;style!css&amp;quot;,
    },
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;étrangeté, c&amp;rsquo;est l&amp;rsquo;appel du css dans le &lt;code&gt;main.js&lt;/code&gt;, et pas dans l&amp;rsquo;&lt;code&gt;index.html&lt;/code&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# src/js/main.js

import &#39;../css/main.css&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mais c&amp;rsquo;est comme cela que l&amp;rsquo;on va pouvoir gérer nos css avec Webpack, comme un module js.&lt;/p&gt;

&lt;h1 id=&#34;gestion-des-différents-environnements&#34;&gt;Gestion des différents environnements&lt;/h1&gt;

&lt;p&gt;Il faut maintenant encore améliorer les choses afin de gérer :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;un &lt;strong&gt;sourcemap&lt;/strong&gt; lorsque l&amp;rsquo;on est en développement (on trouve sur la page &lt;a href=&#34;https://github.com/ryanseddon/source-map/wiki/Source-maps:-languages,-tools-and-other-info&#34;&gt;Source maps: languages, tools and other info&lt;/a&gt; plein d&amp;rsquo;informations sur les sourcemaps)&lt;/li&gt;
&lt;li&gt;la génération d&amp;rsquo;un fichier js optimisé (minimisé) et d&amp;rsquo;un fichier css séparé pour le site de production,&lt;/li&gt;
&lt;li&gt;quelques variables permettant de bien distinguer l&amp;rsquo;environnement de développement et celui de production, comme le titre de la page, le nom du css et du js finale,&lt;/li&gt;
&lt;li&gt;la gestion du &lt;strong&gt;&lt;em&gt;cache busting&lt;/em&gt;&lt;/strong&gt; des assets.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pour cela on va utiliser quelques nouveaux modules et plugins webpack :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/lorenwest/node-config&#34;&gt;&lt;strong&gt;config&lt;/strong&gt;&lt;/a&gt; permettant de gérer des fichiers de configuration différents entre le dev et la prod,&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/ampedandwired/html-webpack-plugin&#34;&gt;&lt;strong&gt;html-webpack-plugin&lt;/strong&gt;&lt;/a&gt; permettant de mieux gérer nos sorties webpack à partir d&amp;rsquo;un template html,&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/webpack/extract-text-webpack-plugin&#34;&gt;&lt;strong&gt;extract-text-webpack-plugin&lt;/strong&gt;&lt;/a&gt; permettant de générer un fichier css final.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Le plugin &lt;strong&gt;html-webpack-plugin&lt;/strong&gt; est tout simplement génial, et je vous renvoie vers l&amp;rsquo;article de &lt;a href=&#34;http://www.jonathan-petitcolas.com/&#34;&gt;Jonathan Petitcolas&lt;/a&gt; pour découvrir tout son potentiel : &lt;a href=&#34;http://marmelab.com/blog/2016/01/26/webpack-html-plugin-in-a-nutshell.html&#34;&gt;Webpack HTML plug-in in a nutshell&lt;/a&gt;.&lt;br /&gt;
Le module &lt;strong&gt;config&lt;/strong&gt; va lui permettre de gérer un fichier de configuration (&lt;code&gt;config/default.js&lt;/code&gt;) accessible depuis le code, et l&amp;rsquo;on va pouvoir surcharger cette configuration selon les environnements de node &lt;strong&gt;NODE_ENV&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install config  html-webpack-plugin  extract-text-webpack-plugin –save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# webpack.config.babel.js

import path from &#39;path&#39;;
import plugins from &#39;./webpack/plugins&#39;;
import ExtractTextPlugin from &#39;extract-text-webpack-plugin&#39;;

const dirJs = path.resolve(__dirname, &#39;src/js&#39;);
const dirHtml = path.resolve(__dirname, &#39;src&#39;);
const dirBuild = path.resolve(__dirname, &#39;build&#39;);

module.exports = {
    entry: path.resolve(dirJs, &#39;main.js&#39;),
    output: {
        path: dirBuild,
        filename: &#39;js/road_to_caen.js&#39;, // On génère un fichier js final nommé
    },
    module: {
        loaders: [
            {
                test: /\.js$/, // le loader des fichiers js
                loader: &#39;babel-loader&#39;, // on transpile l&#39;ES6 avec Babel
                exclude: /node_modules/,
            },
            {
                test: /\.css$/, // le loader des css
                // Ici on traite différemment le css selon l&#39;environnement : en dev on l&#39;inject avec le javascript
                // en prod, on génère un fichier css distinct grace au extract-text-webpack-plugin
                loader: process.env.NODE_ENV === &#39;dev&#39; ? &#39;style!css&#39; : ExtractTextPlugin.extract(&amp;quot;style-loader&amp;quot;, &amp;quot;css-loader&amp;quot;),
            },
        ],
    },
    plugins: plugins(process.env.NODE_ENV, dirHtml), // On appel un fichier de conf des plugin distinct en passant l&#39;environnement
    stats: {
        colors: true,
    },
    // On va créer un fichier sourcemap si l&#39;on est en environnement de développement
    devtool: process.env.NODE_ENV === &#39;dev&#39; ? &#39;source-map&#39; : false,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# webpack/plugin.js

import config from &#39;config&#39;; // on appel le module de configuration
import ExtractTextPlugin from &#39;extract-text-webpack-plugin&#39;;
import HtmlWebpackPlugin from &#39;html-webpack-plugin&#39;;
import webpack from &#39;webpack&#39;;

export default (env, dirHtml) =&amp;gt; {
    const pluginsArray = [
        // Avoid publishing files when compilation fails
        new webpack.NoErrorsPlugin(),
        new HtmlWebpackPlugin({
            hash: env === &#39;prod&#39;, // ici, on génère le cache busting des assets si l&#39;on est en prod
            title: config.app_name, // définit une variable utilisable dans le template html. On recupère le titre depuis la config
            template: dirHtml + &#39;/index.html&#39;,
        }),
    ];
    if (env === &#39;prod&#39;) {
        pluginsArray.push(
            // Ici on configure le plugin permettant de générer le fichier css de production
            new ExtractTextPlugin(&#39;css/road_to_caen.css&#39;, {
                allChunks: true,
            })
        );
    }

    return pluginsArray;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Remarque&lt;/em&gt;&lt;/strong&gt; : &lt;em&gt;Le fichier de configuration de webpack a été renommé en &lt;code&gt;webpack.config.babel.js&lt;/code&gt;: c&amp;rsquo;est ce qui permet d&amp;rsquo;utiliser de l&amp;rsquo;ES6 dans ce fichier js :).&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# src/index.html

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;!-- On utilise la variable options de webpack --&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;%= htmlWebpackPlugin.options.title %&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;!-- Plus besoin d&#39;appeller le fichier css, webpack va injecter l&#39;appel pour la production --&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;h1&amp;gt;Road to Caen - version 0.1.0&amp;lt;/h1&amp;gt;

&amp;lt;div id=&amp;quot;start_here&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;!-- Plus besoin d&#39;appeller le fichier js, webpack va injecter l&#39;appel pour la production --&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# build/index.html - le fichier html final de production

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;!-- On a bien le nom de production défini dans le fichier config/prod.js --&amp;gt;
    &amp;lt;title&amp;gt;Road to Caen&amp;lt;/title&amp;gt;
    &amp;lt;!-- L&#39;appel au fichier css final est bien fait, avec du cache busting. Ce fichier est bien minifié  --&amp;gt;
&amp;lt;link href=&amp;quot;css/road_to_caen.css?e79fbcf65e16662aa388&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;h1&amp;gt;Road to Caen - version 0.1.0&amp;lt;/h1&amp;gt;

&amp;lt;div id=&amp;quot;start_here&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;!-- L&#39;appel au fichier js final est bien fait, avec du cache busting. Ce fichier est bien minifié --&amp;gt;
&amp;lt;script src=&amp;quot;js/road_to_caen.js?e79fbcf65e16662aa388&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# makefile

.PHONY: default install run test build clean-build

default: run-dev

install:
    @npm install

clean-build:
    @rm -rf ./build/*

build: clean-build
    # On défini l&#39;environnement de node comme prod pour le build de production
    # On ajoute l&#39;option -p (production) pour la minification des assets
    # --progress permet de visualiser l&#39;avancement du build sur la console
    @NODE_ENV=prod ./node_modules/.bin/webpack -p --progress

run-dev: clean-build
    # On défini l&#39;environnement de node comme dev pour le webpack-dev-server
    @NODE_ENV=dev ./node_modules/.bin/webpack-dev-server --hot --inline --port=8080
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;les-tests-unitaires&#34;&gt;Les tests unitaires&lt;/h1&gt;

&lt;p&gt;On y est presque ! Mais il manque encore les tests unitaires qui seront réalisés avec &lt;a href=&#34;https://mochajs.org/&#34;&gt;mocha&lt;/a&gt; et &lt;a href=&#34;http://chaijs.com/&#34;&gt;chai&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install mocha chai --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# makefile

test-unit:
    # On indique à mocha ou trouver les fichiers de test : src/js/**/*.spec.js
    # On ajoute un compileur à mocha, pour pouvoir écrire les tests en ES6 : --compilers js:babel-core/register
    # On configure la sortie de console de mocha avec --reporter spec --ui bdd
    @NODE_ENV=test node_modules/.bin/mocha src/js/**/*.spec.js --compilers js:babel-core/register --reporter spec --ui bdd --timeout 5000

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Concernant les fichiers de tests unitaires, je trouve cela plus pratique et plus cohérent de créer le fichier à côté du fichier testé unitairement en rajoutant un &lt;code&gt;.spec&lt;/code&gt;, plutôt que de les mettre dans un répertoire &lt;code&gt;/tests&lt;/code&gt; distinct.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├── src
│   ├── css
│   │   └── main.css
│   ├── index.html
│   └── js
│       ├── main.js
│       ├── paris.js
│       └── paris.spec.js
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# src/js/paris.spec.js

import city from &#39;./paris&#39;;
import { assert } from &#39;chai&#39;;

describe(&#39;city&#39;, () =&amp;gt; {
    it(&#39;should export &amp;quot;Paris&amp;quot; as city&#39;, () =&amp;gt; {
        assert.equal(city, &#39;Paris&#39;);
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;les-tests-fonctionnels&#34;&gt;Les tests fonctionnels&lt;/h1&gt;

&lt;p&gt;Pour que les tests soient complets, il manque encore les tests fonctionnels. Pour les réaliser, je vais utiliser &lt;a href=&#34;http://nightwatchjs.org/&#34;&gt;Nightwatch&lt;/a&gt;.
Mais tout d&amp;rsquo;abord, pour faire des tests fonctionnels, on va avoir besoin d&amp;rsquo;un build de prod et d&amp;rsquo;un serveur permettant à Nightwatch d&amp;rsquo;appeler une URL à tester.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;exposition http des fichiers statiques finaux sera assurée par &lt;a href=&#34;https://github.com/indexzero/http-server&#34;&gt;http-server&lt;/a&gt;.  Lors de l&amp;rsquo;execution des tests, il va falloir gérer :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1) le lancement du serveur des statiques&lt;/li&gt;
&lt;li&gt;2) le lancement d&amp;rsquo;un serveur &lt;a href=&#34;http://www.seleniumhq.org/&#34;&gt;selenium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;3) l&amp;rsquo;execution des tests&lt;/li&gt;
&lt;li&gt;4) l&amp;rsquo;arrêt du selenium&lt;/li&gt;
&lt;li&gt;5) l&amp;rsquo;arrêt du serveur de statiques&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cela peut se gérer via les &lt;code&gt;PID&lt;/code&gt; des instances de serveurs&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;start-static-server: static-server.PID
static-server.PID:
	@echo &amp;quot;Starting static server&amp;quot;
	@cd ./build &amp;amp;&amp;amp; { ../node_modules/.bin/http-server -p 8081 &amp;amp; echo $$! &amp;gt; ../$@; } &amp;amp;&amp;amp; cd ..
stop-static-server: static-server.PID
	@kill `cat $&amp;lt;` &amp;amp;&amp;amp; rm $&amp;lt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mais je n&amp;rsquo;aime pas trop cette solution, qui présente entre l&amp;rsquo;autre l&amp;rsquo;inconvéniant de laisser trainer des fichiers &lt;code&gt;.PID&lt;/code&gt; en cas d&amp;rsquo;échec des tests, empêchant la relance des serveurs après correctif.&lt;br /&gt;
J&amp;rsquo;ai trouvé une solution plus élégante consistant à utiliser &lt;a href=&#34;http://pm2.keymetrics.io/&#34;&gt;PM2&lt;/a&gt; pour gérer les serveurs lors des tests. J&amp;rsquo;ai soumis cette solution à mes &lt;a href=&#34;http://marmelab.com/&#34;&gt;éminents collègues marmelabien&lt;/a&gt; et en fonction de leurs retours, je ferais un petit post spécifique sur l&amp;rsquo;utilisation de PM2 en environnement de développement et de tests.
Mais voici ce que cela donne pour &lt;em&gt;Road to Caen&lt;/em&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install nightwatch selenium-standalone pm2 --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# rtc_functional_test.json : le fichier de configuration des serveurs de PM2

{
  &amp;quot;apps&amp;quot; : [{
    &amp;quot;name&amp;quot;       : &amp;quot;rtc-static-server&amp;quot;, // le nom du serveur
    &amp;quot;script&amp;quot;     : &amp;quot;./node_modules/.bin/http-server&amp;quot;, // l&#39;appel au serveur
    &amp;quot;args&amp;quot;       : [&amp;quot;./build&amp;quot;, &amp;quot;-p 8088&amp;quot;, &amp;quot;--silent&amp;quot;], // les options
    &amp;quot;instances&amp;quot;  : 1
  }]
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# nightwatch.json : le fichier de configuration de Nightwatch

{
    &amp;quot;src_folders&amp;quot;: [&amp;quot;./test-functional/&amp;quot;], // repertoire des tests fonctionnels
    &amp;quot;output_folder&amp;quot;: &amp;quot;./test-functional/reports&amp;quot;, // repertoire des rapports de tests
    &amp;quot;custom_commands_path&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;custom_assertions_path&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;globals_path&amp;quot;: &amp;quot;&amp;quot;,

    &amp;quot;selenium&amp;quot;: {
        &amp;quot;start_process&amp;quot;: true, // Nightwatch se charge de lancer et d&#39;eteindre selenium !
        &amp;quot;server_path&amp;quot;: &amp;quot;./node_modules/selenium-standalone/.selenium/selenium-server/2.48.2-server.jar&amp;quot;,
        &amp;quot;log_path&amp;quot;: &amp;quot;&amp;quot;,
        &amp;quot;host&amp;quot;: &amp;quot;127.0.0.1&amp;quot;,
        &amp;quot;port&amp;quot;: 4444,
        &amp;quot;cli_args&amp;quot;: {
            &amp;quot;webdriver.chrome.driver&amp;quot;: &amp;quot;./node_modules/selenium-standalone/.selenium/chromedriver/2.21-x64-chromedriver&amp;quot;,
            &amp;quot;webdriver.ie.driver&amp;quot;: &amp;quot;&amp;quot;
        }
    },

    &amp;quot;test_settings&amp;quot;: {
        &amp;quot;default&amp;quot;: {
            &amp;quot;launch_url&amp;quot;: &amp;quot;http://localhost:8088&amp;quot;,
            &amp;quot;selenium_port&amp;quot;: 4444,
            &amp;quot;selenium_host&amp;quot;: &amp;quot;localhost&amp;quot;,
            &amp;quot;silent&amp;quot;: true,
            &amp;quot;firefox_profile&amp;quot; : false,
            &amp;quot;desiredCapabilities&amp;quot;: {
                &amp;quot;browserName&amp;quot;: &amp;quot;chrome&amp;quot;,
                &amp;quot;javascriptEnabled&amp;quot;: true,
                &amp;quot;acceptSslCerts&amp;quot;: true
            },
            &amp;quot;screenshots&amp;quot;: {
                &amp;quot;enabled&amp;quot;: true,
                &amp;quot;path&amp;quot;: &amp;quot;./test-functional/screen-caps&amp;quot;
            },
            &amp;quot;desiredCapabilities&amp;quot;: {
              &amp;quot;browserName&amp;quot;: &amp;quot;firefox&amp;quot;,
              &amp;quot;javascriptEnabled&amp;quot;: true,
              &amp;quot;acceptSslCerts&amp;quot;: true
            }
        },
        &amp;quot;firefox&amp;quot;: {
            &amp;quot;desiredCapabilities&amp;quot;: {
                &amp;quot;browserName&amp;quot;: &amp;quot;firefox&amp;quot;,
                &amp;quot;javascriptEnabled&amp;quot;: true
            }
        },
        &amp;quot;chrome&amp;quot;: {
            &amp;quot;desiredCapabilities&amp;quot;: {
                &amp;quot;browserName&amp;quot;: &amp;quot;chrome&amp;quot;,
                &amp;quot;javascriptEnabled&amp;quot;: true
            }
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# makefile
.PHONY: default install run test build clean-build

install:
    @npm install
    # On lance l&#39;installation du serveur selenium
    @node_modules/.bin/selenium-standalone install --version=2.48.2


test-functional: clean-build
    # lancement du build des fichiers statiques finaux identiques à la prod
    @make build
    # lancement du serveur statique avec pm2 en indiquant le fichier de configuration du serveur
    @node_modules/.bin/pm2 start rtc_functional_tests.json
    # lancement de nightwatch, qui va se charger de l&#39;instance de selenium
    @node_modules/.bin/nightwatch
    # arret du serveur statique
    @node_modules/.bin/pm2 stop rtc-static-server
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# test-functional/home.spec.js : fichier de tests de l&#39;accueil du site

module.exports = {
    &#39;Display Home&#39;: function (client) {
        client
            .url(&#39;http://localhost:8088&#39;)
            .pause(1000);

        client.expect.element(&#39;body&#39;).to.be.present.before(1000);
        client.expect.element(&#39;#start_here&#39;).text.to.equal(&#39;For the moment, you are in Paris&#39;);

        client.end();
    },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Remarque&lt;/em&gt;&lt;/strong&gt; : &lt;em&gt;Je n&amp;rsquo;ai pas encore trouver comment écrire les tests fonctionnels en ES6 :(&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;la-touche-finale-le-code-styling&#34;&gt;La touche finale: le « code styling »&lt;/h1&gt;

&lt;p&gt;Pour terminer cet environnement de développement ES6, on va ajouter un dernier outil permettant d&amp;rsquo;être cohérent sur le code styling du projet : &lt;a href=&#34;http://eslint.org/&#34;&gt;ESLint&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install eslint eslint-config-airbnb eslint-plugin-mocha --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eslint se configure dans un fichier &lt;code&gt;.eslintrc&lt;/code&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    &amp;quot;extends&amp;quot;: &amp;quot;airbnb&amp;quot;,
    &amp;quot;env&amp;quot;: {
        &amp;quot;mocha&amp;quot;: true,
    },
    &amp;quot;rules&amp;quot;: {
        &amp;quot;indent&amp;quot;: [2, 4],
    },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;J&amp;rsquo;utilise le preset airbnb, qui gère bien l&amp;rsquo;ES6, mais aussi la syntaxe particulière de Redux. Je ne lance pas de tests directement avec ESLint, mais j&amp;rsquo;utilise avec &lt;a href=&#34;https://atom.io/&#34;&gt;ATOM&lt;/a&gt; le plugin &lt;a href=&#34;https://atom.io/packages/linter-eslint&#34;&gt;linter-eslint&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Alors, &lt;a href=&#34;https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.6bg742tti&#34;&gt;&lt;strong&gt;&lt;em&gt;JavaScript fatigue&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt; ? Il est vrai que cette phase de bootstraping est assez longue, et oblige à voir et comprendre pas mal d&amp;rsquo;outils. Un &lt;code&gt;ls&lt;/code&gt; dans le répertoire des &lt;code&gt;node_modules&lt;/code&gt; est plutôt impressionnant ! On est tenté de se dire : &lt;em&gt;tout ça pour générer un (encore) pauvre fichier js final ?&lt;/em&gt;&lt;br /&gt;
Eh bien oui, mais j&amp;rsquo;oppose à cela plusieurs remarques.&lt;/p&gt;

&lt;p&gt;Tout d&amp;rsquo;abord, on est en présence d&amp;rsquo;un environnement de développement complet permettant :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;d&amp;rsquo;écrire en ES6 du code qui sera lisible sur tout les navigateurs,&lt;/li&gt;
&lt;li&gt;de générer des assets finaux optimisés,&lt;/li&gt;
&lt;li&gt;de disposer d&amp;rsquo;un serveur de développement très rapide assurant le live-reload,&lt;/li&gt;
&lt;li&gt;d&amp;rsquo;écrire des tests unitaires et fonctionnels,&lt;/li&gt;
&lt;li&gt;de s&amp;rsquo;assurer de la cohérence de la syntaxe du projet.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://alexisjanvier.github.io/images/rtc_bootstrap/rtcBootstrapOk.gif&#34; alt=&#34;L&#39;environnement final&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ensuite, toutes ces librairies et autres modules envahissant le répertoire &lt;code&gt;node_modules&lt;/code&gt; ne sont là &lt;strong&gt;que pour l&amp;rsquo;environnement de développement&lt;/strong&gt;. Rien de cela n&amp;rsquo;est visible au final sur ce qui sera mis en production.&lt;br /&gt;
C&amp;rsquo;est donc une espèce d&amp;rsquo;usine Lego à produire du code final optimisé, pas de la surcharge de code.&lt;/p&gt;

&lt;p&gt;Et ceci nous oblige en tant que développeur a bien connaître et si possible à maitriser ces outils, plutôt que de les avoir comme une boite noire intégrée à un IDE :)&lt;/p&gt;

&lt;p&gt;En plus, un simple &lt;code&gt;make install&lt;/code&gt;, et &amp;ldquo;&lt;strong&gt;&lt;em&gt;tadam&lt;/em&gt;&lt;/strong&gt;&amp;rdquo;, tout est prêt !&lt;/p&gt;

&lt;p&gt;Si vous voulez voir un autre bootstraping encore plus complet, car intégrant un serveur back en &lt;a href=&#34;http://koajs.com/&#34;&gt;Koa&lt;/a&gt; et un front en &lt;a href=&#34;https://facebook.github.io/react/&#34;&gt;React&lt;/a&gt;/&lt;a href=&#34;http://redux.js.org/&#34;&gt;Redux&lt;/a&gt;, vous pouvez jeter un coup d&amp;rsquo;oeil à ce dépôt : &lt;a href=&#34;https://github.com/marmelab/javascript-boilerplate&#34;&gt;marmelab/javascript-boilerplate&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Tout le code du bootstrap de &lt;code&gt;Road to Caen&lt;/code&gt; est également disponible sur Github : &lt;a href=&#34;https://github.com/alexisjanvier/road-to-caen/releases/tag/v0.1.0&#34;&gt;alexisjanvier/road-to-caen&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;La prochaine étape, donc le prochain post, abordera la question du &lt;strong&gt;déploiement continu du projet&lt;/strong&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>